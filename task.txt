the store code is here:
// schemaSlice.js
import labTestService from "../../../services/testService";

const initialSchema = {
  name: "",
  testName: "",
  testId: "",
  categoryId: "",
  isActive: false,
  hasStaticStandardRange: false,
  staticStandardRange: "",
  sections: [{ name: "Default", fields: [] }],
  currentSectionName: "",
};

const schemaSlice = (set, get) => ({
  testList: [],
  schema: { ...initialSchema },

  // Reset schema to initial state
  resetSchema: () => {
    set({ schema: { ...initialSchema } });
  },

  setFullSchema: (newSchema) => {
    set({ schema: { ...initialSchema, ...newSchema } });
  },

  setSchema: (field, value) => {
    set((state) => ({
      schema: { ...state.schema, [field]: value },
    }));
  },

  loadTestList: async () => {
    try {
      get().startLoading();
      const response = await labTestService.getTestList()
      set({ testList: response.data });
    } catch (e) {
      get().setPopup({
        type: "error",
        message: "Failed to load tests. Please try again.",
      });
    } finally {
      get().stopLoading();
    }
  },

  isSectionNameUnique: (name, excludeName = null) => {
    const sections = get().schema.sections;
    const normalized = name.toLowerCase().trim();
    return !sections.some((s) => {
      if (excludeName && s.name === excludeName) return false;
      return s.name.toLowerCase().trim() === normalized;
    });
  },

  addSection: () => {
    const name = get().schema.currentSectionName.trim();
    if (!name) return;
    if (!get().isSectionNameUnique(name)) {
      get().setPopup({
        type: "error",
        message: `Section "${name}" already exists!`,
      });
      return false;
    }
    set((state) => ({
      schema: {
        ...state.schema,
        sections: [...state.schema.sections, { name, fields: [] }],
        currentSectionName: "",
      },
    }));
    get().setPopup({
      type: "success",
      message: `Section "${name}" added successfully!`,
    });
    return true;
  },

  deleteSection: (sectionName) => {
    if (get().schema.sections.length === 1) {
      get().setPopup({
        type: "error",
        message: "Cannot delete the last section!",
      });
      return;
    }
    set((state) => ({
      schema: {
        ...state.schema,
        sections: state.schema.sections.filter((s) => s.name !== sectionName),
      },
    }));
    get().setPopup({
      type: "success",
      message: `Section "${sectionName}" deleted!`,
    });
  },

  updateSection: (oldName, newName) => {
    const trimmed = newName.trim();
    if (!trimmed) return;
    if (!get().isSectionNameUnique(trimmed, oldName)) {
      get().setPopup({
        type: "error",
        message: `Section "${trimmed}" already exists!`,
      });
      return;
    }
    set((state) => ({
      schema: {
        ...state.schema,
        sections: state.schema.sections.map((s) => (s.name === oldName ? { ...s, name: trimmed } : s)),
      },
    }));
    get().setPopup({
      type: "success",
      message: "Section renamed successfully!",
    });
  },

  confirmRemoveStaticStandardRange: () => {
    get().setPopup({
      type: "confirmation",
      message: "This will delete all reference values. Continue?",
      onConfirm: () => {
        set((state) => ({
          schema: {
            ...state.schema,
            hasStaticStandardRange: false,
            staticStandardRange: "",
          },
        }));
        get().setPopup({
          type: "success",
          message: "Standard range disabled.",
        });
      },
    });
  },

  addField: (sectionName, newField) =>
    set((state) => {
      const updatedSections = state.schema?.sections?.map((sec) => {
        if (sec.name === sectionName) {
          return {
            ...sec,
            fields: [...(sec.fields || []), newField],
          };
        }
        return sec;
      });
      return {
        schema: {
          ...state.schema,
          sections: updatedSections,
        },
      };
    }),

  updateField: (sectionName, oldFieldName, updatedField) =>
    set((state) => {
      const updatedSections = state.schema.sections.map((sec) => {
        if (sec.name === sectionName) {
          const updatedFields = sec.fields.map((field) => (field.name === oldFieldName ? updatedField : field));
          return { ...sec, fields: updatedFields };
        }
        return sec;
      });
      return {
        schema: {
          ...state.schema,
          sections: updatedSections,
        },
      };
    }),

  deleteField: (sectionName, fieldName) =>
    set((state) => {
      const updatedSections = state.schema.sections.map((sec) => {
        if (sec.name === sectionName) {
          return {
            ...sec,
            fields: sec.fields.filter((field) => field.name !== fieldName),
          };
        }
        return sec;
      });
      return {
        schema: {
          ...state.schema,
          sections: updatedSections,
        },
      };
    }),

  clearStaticStandardRange: () => {
    set((state) => ({
      schema: { ...state.schema, staticStandardRange: "" },
    }));
  },
});

export default schemaSlice;



and the parent component is:

import { useEffect } from "react";
import schemaService from "../../services/schemaService";
import useStore from "./store";
import Popup from "../../components/popup/Popup";
import LoadingScreen from "../../components/loadingPage";
import SchemaInfo from "./SchemaInfo";
import SelectTest from "./SelectTest";
import Status from "./Status";
import Section from "./Section";
import SchemaPreview from "./SchemaPreview";
import StaticStandardRange from "./StaticStandardRange";
import AddField from "./AddField"; // Updated component
import FormPreview from "./FormPreview";
import FormRenderer from "./FormRenderer";
import { useParams } from "react-router-dom";

const SchemaBuilder = () => {
  const {
    schema,
    setSchema,
    setFullSchema, // Add this
    deleteSection,
    setPopup,
    popup,
    closePopup,
    loading,
    startLoading,
    stopLoading,
    resetSchema,
  } = useStore();
  const { schemaId } = useParams();
  // Fetch existing schema when in edit mode
  useEffect(() => {
    const fetchExistingSchema = async () => {
      if (schemaId) {
        startLoading();
        try {
          const response = await schemaService.getById(schemaId);
          const existingSchema = response.data;
          console.log(existingSchema);
          setFullSchema(existingSchema); // Fixed: Use the new action
        } catch (error) {
          console.error("Error fetching schema:", error);
          setPopup({ type: "error", message: "Failed to load schema for editing" });
          // navigate("/schema-list");
        } finally {
          stopLoading();
        }
      }
    };
    fetchExistingSchema();
    return () => {
      resetSchema();
    };
  }, [schemaId]);
  const handleSubmit = async () => {
    try {
      setSchema("currentSectionName", undefined); // Fixed: Use setter instead of delete/mutation
      if (!schemaId) {
        // Add new schema
        startLoading();
        console.log(schema);
        const response = await schemaService.addNew(schema);
        // console.log(response.data);
        setPopup({ type: "success", message: "Schema added successfully", data: null, action: null });
      } else {
        const response = await schemaService.update(schemaId, schema);
        console.log(response.data);
        setPopup({ type: "success", message: "Schema updated successfully", data: null, action: null });
      }
    } catch (e) {
      setPopup({ type: "error", message: "Failed to add schema", data: null, action: null });
    } finally {
      stopLoading();
    }
  };
  return (
    <div className="min-h-screen bg-gray-50 pb-4 pt-2 md:p-6">
      {loading && <LoadingScreen />}
      {/* Popups */}
      {popup && popup.type === "success" && <Popup type="success" message={popup.message} onClose={closePopup} />}
      {popup && popup.type === "error" && <Popup type="error" message={popup.message} onClose={closePopup} />}
      {popup && popup.type === "confirmation" && (
        <Popup type="confirmation" message={popup.message} onClose={closePopup} onConfirm={popup.onConfirm} />
      )}
      {popup && popup.type === "confirmation" && popup.action === "deleteSection" && (
        <Popup
          type="confirmation"
          message={popup.message}
          onClose={closePopup}
          onConfirm={() => deleteSection(popup.data)}
        />
      )}
      {/* No more modal for addField; handled inline now */}
      <div className="max-w-4xl mx-auto space-y-6 -mt-3">
        {/* Header */}
        <div className="text-center mb-2">
          <h1 className="text-lg md:text-xl font-bold text-gray-800">Schema Engine</h1>
        </div>
        {/* Row 1: Schema Name and Test Name */}
        <SchemaInfo />
        {/* Row 2: Test Category & Test Selection */}
        <SelectTest />
        {/* Row 3: Status Toggle */}
        <Status />
        {/* Row 4: Sections */}
        <Section />
        {/* Row 4.5: Add Field (now with inline form) */}
        <AddField />
        {/* Row 5: Standard Range */}
        <StaticStandardRange />
        <div className="w-full flex justify-center items-center">
          <button onClick={handleSubmit} className="btn">
            Save Schema
          </button>
        </div>
        {/* Row 6: Preview Form */}
        <FormPreview />
        {/* Row 7: Preview Form */}
        <FormRenderer />
        {/* Row 8: Schema Preview */}
        <SchemaPreview />
      </div>
    </div>
  );
};
export default SchemaBuilder


and the children components are:
import { useState, useEffect } from "react";
import useStore from "./store";
import InputField from "../../components/html/InputField";
import SelectField from "../../components/html/SelectField";
import Icons from "../../components/icons"; // Update this path

const AddField = () => {
  const { Add: AddIcon, Edit: EditIcon, Delete: DeleteIcon, Close: CloseIcon } = Icons;

  const { schema, addField, setPopup } = useStore();

  const [showAddFieldForm, setShowAddFieldForm] = useState(false);
  const [fieldName, setFieldName] = useState("");
  const [fieldType, setFieldType] = useState("input");
  const [isRequired, setIsRequired] = useState(false);
  const [selectedSection, setSelectedSection] = useState("");
  const [maxLength, setMaxLength] = useState("");
  const [options, setOptions] = useState([]);
  const [standardRangeType, setStandardRangeType] = useState("none");
  const [rangeData, setRangeData] = useState(null);
  const [unit, setUnit] = useState(""); // Selected from dropdown
  const [customUnit, setCustomUnit] = useState(""); // For "Other"

  // Option editor
  const [newOption, setNewOption] = useState("");
  const [editingOptionIndex, setEditingOptionIndex] = useState(null);
  const [editingOptionValue, setEditingOptionValue] = useState("");

  // Range editor
  const [newRangeEntry, setNewRangeEntry] = useState({});
  const [editingRangeIndex, setEditingRangeIndex] = useState(null);

  const sections = schema.sections || [];
  const hasMultipleSections = sections.length > 1;

  // Common Medical Units
  const commonMedicalUnits = [
    { value: "", label: "No unit" },
    { value: "mg/dL", label: "mg/dL" },
    { value: "g/dL", label: "g/dL" },
    { value: "mmol/L", label: "mmol/L" },
    { value: "µmol/L", label: "µmol/L" },
    { value: "U/L", label: "U/L" },
    { value: "ng/mL", label: "ng/mL" },
    { value: "pg/mL", label: "pg/mL" },
    { value: "10³/µL", label: "10³/µL (thousand/µL)" },
    { value: "10⁶/µL", label: "10⁶/µL (million/µL)" },
    { value: "%", label: "% (Percentage)" },
    { value: "mmHg", label: "mmHg" },
    { value: "bpm", label: "bpm (beats/min)" },
    { value: "°C", label: "°C" },
    { value: "°F", label: "°F" },
    { value: "cm", label: "cm" },
    { value: "m", label: "m" },
    { value: "kg", label: "kg" },
    { value: "g", label: "g" },
    { value: "lbs", label: "lbs" },
    { value: "mL", label: "mL" },
    { value: "cells/HPF", label: "cells/HPF" },
    { value: "mg/24h", label: "mg/24h" },
    { value: "other", label: "Other (type manually)" },
  ];

  const finalUnit = unit === "other" ? customUnit.trim() : unit;

  useEffect(() => {
    if (!hasMultipleSections && sections.length > 0) {
      setSelectedSection(sections[0].name);
    }
  }, [sections, hasMultipleSections]);

  useEffect(() => {
    if (!["select", "checkbox", "radio"].includes(fieldType)) {
      setOptions([]);
      setNewOption("");
      setEditingOptionIndex(null);
      setEditingOptionValue("");
    }
    if (fieldType !== "number") {
      setUnit("");
      setCustomUnit("");
      setStandardRangeType("none");
    }
  }, [fieldType]);

  useEffect(() => {
    if (standardRangeType === "simple") {
      setRangeData({ min: "", max: "" });
    } else if (standardRangeType === "gender") {
      setRangeData({ male: { min: "", max: "" }, female: { min: "", max: "" } });
    } else if (standardRangeType === "age" || standardRangeType === "combined") {
      setRangeData([]);
    } else {
      setRangeData(null);
    }
    setNewRangeEntry({});
    setEditingRangeIndex(null);
  }, [standardRangeType]);

  const needsOptions = ["select", "checkbox", "radio"].includes(fieldType);
  const needsMaxLength = ["input", "textarea"].includes(fieldType);
  const needsStandardRange = fieldType === "number" && standardRangeType !== "none";

  // Handlers (unchanged)
  const handleAddOption = () => {
    if (newOption.trim()) {
      setOptions([...options, newOption.trim()]);
      setNewOption("");
    }
  };

  const handleRemoveOption = (i) => setOptions(options.filter((_, idx) => idx !== i));
  const handleStartEditOption = (i, val) => {
    setEditingOptionIndex(i);
    setEditingOptionValue(val);
  };
  const handleSaveEditOption = () => {
    if (editingOptionValue.trim()) {
      const updated = [...options];
      updated[editingOptionIndex] = editingOptionValue.trim();
      setOptions(updated);
      setEditingOptionIndex(null);
      setEditingOptionValue("");
    }
  };
  const handleCancelEditOption = () => {
    setEditingOptionIndex(null);
    setEditingOptionValue("");
  };

  const handleSimpleOrGenderChange = (key, subKey, val) => {
    setRangeData((prev) => ({ ...prev, [key]: subKey ? { ...prev[key], [subKey]: val } : val }));
  };

  const handleNewRangeChange = (key, val) => {
    setNewRangeEntry((prev) => ({ ...prev, [key]: val }));
  };

  const validateRangeEntry = (entry, type) => {
    if (type === "age") return entry.minAge && entry.minValue && entry.maxValue;
    if (type === "combined") return entry.gender && entry.minAge && entry.minValue && entry.maxValue;
    return false;
  };

  const handleAddOrUpdateRange = () => {
    if (validateRangeEntry(newRangeEntry, standardRangeType)) {
      const entry = { ...newRangeEntry };
      if (!entry.maxAge) entry.maxAge = 999;

      if (editingRangeIndex !== null) {
        const updated = [...rangeData];
        updated[editingRangeIndex] = entry;
        setRangeData(updated);
        setEditingRangeIndex(null);
        setPopup({ type: "success", message: "Range updated" });
      } else {
        setRangeData((prev) => [...prev, entry]);
        setPopup({ type: "success", message: "Range added" });
      }
      setNewRangeEntry({});
    } else {
      setPopup({ type: "error", message: "Fill all required fields" });
    }
  };

  const handleRemoveRange = (i) => setRangeData((prev) => prev.filter((_, idx) => idx !== i));
  const handleStartEditRange = (i) => {
    setEditingRangeIndex(i);
    setNewRangeEntry({ ...rangeData[i] });
  };
  const handleCancelEditRange = () => {
    setEditingRangeIndex(null);
    setNewRangeEntry({});
  };

  const handleSubmit = () => {
    if (!fieldName.trim()) return setPopup({ type: "error", message: "Field name required" });
    if (hasMultipleSections && !selectedSection) return setPopup({ type: "error", message: "Select a section" });

    const allFields = sections.flatMap((s) => s.fields || []);
    if (allFields.some((f) => f.name === fieldName))
      return setPopup({ type: "error", message: "Field name already exists" });

    if (needsOptions && options.length === 0) return setPopup({ type: "error", message: "Add at least one option" });

    if (needsStandardRange) {
      if (standardRangeType === "simple" && (!rangeData.min || !rangeData.max))
        return setPopup({ type: "error", message: "Min and max required" });
      if (
        standardRangeType === "gender" &&
        (!rangeData.male?.min || !rangeData.male?.max || !rangeData.female?.min || !rangeData.female?.max)
      )
        return setPopup({ type: "error", message: "Min/max required for both genders" });
      if ((standardRangeType === "age" || standardRangeType === "combined") && rangeData.length === 0)
        return setPopup({ type: "error", message: "Add at least one range" });
    }

    const sectionName = selectedSection || sections[0]?.name;
    const newField = { name: fieldName, type: fieldType, required: isRequired };

    if (needsOptions) newField.options = options;
    if (needsMaxLength && maxLength) newField.maxLength = parseInt(maxLength, 10);
    if (needsStandardRange) newField.standardRange = { type: standardRangeType, data: rangeData };
    if (fieldType === "number" && finalUnit) newField.unit = finalUnit;

    addField(sectionName, newField);
    resetForm();
  };

  const resetForm = () => {
    setFieldName("");
    setFieldType("input");
    setIsRequired(false);
    setMaxLength("");
    setOptions([]);
    setStandardRangeType("none");
    setRangeData(null);
    setUnit("");
    setCustomUnit("");
    setNewOption("");
    setEditingOptionIndex(null);
    setEditingOptionValue("");
    setNewRangeEntry({});
    setEditingRangeIndex(null);
    setSelectedSection(hasMultipleSections ? "" : sections[0]?.name || "");
    setShowAddFieldForm(false);
  };

  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      {/* Header */}
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-6">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">Fields</h3>
          <p className="text-sm text-gray-600">Add fields to sections</p>
        </div>
        {!showAddFieldForm && (
          <button
            onClick={() => setShowAddFieldForm(true)}
            className="flex items-center gap-2 px-5 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm"
          >
            <AddIcon className="w-5 h-5" />
            Add Field
          </button>
        )}
      </div>

      {/* Form */}
      {showAddFieldForm && (
        <div className="p-6 bg-blue-50 border border-blue-200 rounded-xl">
          <div className="flex items-center justify-between mb-6">
            <h4 className="text-lg font-semibold text-gray-800">Add New Field</h4>
            <button onClick={() => setShowAddFieldForm(false)} className="text-gray-500 hover:text-gray-700">
              <CloseIcon className="w-6 h-6" />
            </button>
          </div>

          <div className="space-y-6">
            {/* Section */}
            {hasMultipleSections && (
              <SelectField
                label="Attach to Section"
                value={selectedSection}
                onChange={(e) => setSelectedSection(e.target.value)}
                options={sections.map((s) => ({ value: s.name, label: s.name }))}
              />
            )}
            {!hasMultipleSections && sections.length > 0 && (
              <p className="text-sm text-gray-600">
                Attaching to: <span className="font-medium">{sections[0].name}</span>
              </p>
            )}

            <InputField label="Field Name" value={fieldName} onChange={(e) => setFieldName(e.target.value)} />

            <SelectField
              label="Field Type"
              value={fieldType}
              onChange={(e) => setFieldType(e.target.value)}
              options={[
                { value: "input", label: "Text Input" },
                { value: "textarea", label: "Textarea" },
                { value: "select", label: "Select Dropdown" },
                { value: "checkbox", label: "Checkbox Group" },
                { value: "radio", label: "Radio Group" },
                { value: "number", label: "Number Input" },
              ]}
            />

            {needsMaxLength && (
              <InputField
                label="Max Length"
                type="number"
                value={maxLength}
                onChange={(e) => setMaxLength(e.target.value)}
              />
            )}

            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={isRequired}
                onChange={(e) => setIsRequired(e.target.checked)}
                className="w-5 h-5 text-blue-600 rounded"
              />
              <span className="text-sm font-medium text-gray-700">Required field</span>
            </label>

            {/* Options */}
            {needsOptions && (
              <div className="space-y-4">
                <h5 className="text-sm font-semibold text-gray-800">Options</h5>
                {options.map((opt, i) => (
                  <div key={i} className="flex items-center gap-3 p-3 bg-white rounded-lg border">
                    {editingOptionIndex === i ? (
                      <>
                        <input
                          type="text"
                          value={editingOptionValue}
                          onChange={(e) => setEditingOptionValue(e.target.value)}
                          className="flex-1 px-3 py-2 border rounded-md text-sm focus:ring-2 focus:ring-blue-500"
                          autoFocus
                        />
                        <button onClick={handleSaveEditOption} className="text-green-600 font-medium">
                          Save
                        </button>
                        <button onClick={handleCancelEditOption} className="text-gray-600">
                          Cancel
                        </button>
                      </>
                    ) : (
                      <>
                        <span className="flex-1 font-medium text-gray-800">{opt}</span>
                        <button onClick={() => handleStartEditOption(i, opt)} className="text-blue-600">
                          <EditIcon className="w-5 h-5" />
                        </button>
                        <button onClick={() => handleRemoveOption(i)} className="text-red-600">
                          <DeleteIcon className="w-5 h-5" />
                        </button>
                      </>
                    )}
                  </div>
                ))}
                <div className="flex flex-col sm:flex-row gap-3">
                  <InputField label="Option" value={newOption} onChange={(e) => setNewOption(e.target.value)} className="flex-1 pl-2" />
                  <button
                    onClick={handleAddOption}
                    disabled={!newOption.trim()}
                    className="flex items-center justify-center gap-2 px-5 py-2.5 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 font-medium"
                  >
                    <AddIcon className="w-5 h-5" /> Add
                  </button>
                </div>
              </div>
            )}

            {/* Number Field Settings */}
            {fieldType === "number" && (
              <>
                {/* Unit Selection */}
                <div className="space-y-4">
                  <SelectField
                    label="Unit"
                    value={unit}
                    onChange={(e) => {
                      setUnit(e.target.value);
                      if (e.target.value !== "other") setCustomUnit("");
                    }}
                    options={commonMedicalUnits}
                  />

                  {unit === "other" && (
                    <InputField
                      label="Custom Unit"
                      value={customUnit}
                      onChange={(e) => setCustomUnit(e.target.value)}
                    />
                  )}

                  {finalUnit && finalUnit !== "" && (
                    <div className="text-sm text-gray-600">
                      <span className="font-medium">Selected unit:</span> <strong>{finalUnit}</strong>
                    </div>
                  )}
                </div>

                <SelectField
                  label="Standard Range"
                  value={standardRangeType}
                  onChange={(e) => setStandardRangeType(e.target.value)}
                  options={[
                    { value: "none", label: "None" },
                    { value: "simple", label: "Simple Range" },
                    { value: "age", label: "Age Based" },
                    { value: "gender", label: "Gender Based" },
                    { value: "combined", label: "Age + Gender" },
                  ]}
                />

                {/* Simple Range */}
                {standardRangeType === "simple" && rangeData && (
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <InputField
                      label="Min"
                      type="number"
                      value={rangeData.min}
                      onChange={(e) => handleSimpleOrGenderChange("min", null, e.target.value)}
                    />
                    <InputField
                      label="Max"
                      type="number"
                      value={rangeData.max}
                      onChange={(e) => handleSimpleOrGenderChange("max", null, e.target.value)}
                    />
                  </div>
                )}

                {/* Gender Range */}
                {standardRangeType === "gender" && rangeData && (
                  <div className="space-y-4">
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      <InputField
                        label="Male Min"
                        type="number"
                        value={rangeData.male.min}
                        onChange={(e) => handleSimpleOrGenderChange("male", "min", e.target.value)}
                      />
                      <InputField
                        label="Male Max"
                        type="number"
                        value={rangeData.male.max}
                        onChange={(e) => handleSimpleOrGenderChange("male", "max", e.target.value)}
                      />
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      <InputField
                        label="Female Min"
                        type="number"
                        value={rangeData.female.min}
                        onChange={(e) => handleSimpleOrGenderChange("female", "min", e.target.value)}
                      />
                      <InputField
                        label="Female Max"
                        type="number"
                        value={rangeData.female.max}
                        onChange={(e) => handleSimpleOrGenderChange("female", "max", e.target.value)}
                      />
                    </div>
                  </div>
                )}

                {/* Age / Combined Ranges */}
                {(standardRangeType === "age" || standardRangeType === "combined") && rangeData && (
                  <div className="space-y-5">
                    <h5 className="text-sm font-semibold text-gray-800">Ranges</h5>
                    {rangeData.map((r, i) => (
                      <div key={i} className="flex flex-wrap items-center gap-3 p-4 bg-white rounded-lg border text-sm">
                        <div className="flex-1 font-medium">
                          {standardRangeType === "combined" && (
                            <span className="text-blue-600">{r.gender === "male" ? "Male" : "Female"} • </span>
                          )}
                          Age {r.minAge}–{r.maxAge === 999 ? "99+" : r.maxAge}: {r.minValue}–{r.maxValue}
                        </div>
                        <button onClick={() => handleStartEditRange(i)} className="text-blue-600">
                          <EditIcon className="w-5 h-5" />
                        </button>
                        <button onClick={() => handleRemoveRange(i)} className="text-red-600">
                          <DeleteIcon className="w-5 h-5" />
                        </button>
                      </div>
                    ))}

                    <div className="p-5 bg-gray-50 rounded-xl space-y-5 border">
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        {standardRangeType === "combined" && (
                          <SelectField
                            label="Gender"
                            value={newRangeEntry.gender || ""}
                            onChange={(e) => handleNewRangeChange("gender", e.target.value)}
                            options={[
                              { value: "male", label: "Male" },
                              { value: "female", label: "Female" },
                            ]}
                          />
                        )}
                        <InputField
                          label="Min Age"
                          type="number"
                          value={newRangeEntry.minAge || ""}
                          onChange={(e) => handleNewRangeChange("minAge", e.target.value)}
                        />
                        <InputField
                          label="Max Age"
                          type="number"
                          value={newRangeEntry.maxAge || ""}
                          onChange={(e) => handleNewRangeChange("maxAge", e.target.value)}
                        />
                      </div>
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <InputField
                          label="Min Value"
                          type="number"
                          value={newRangeEntry.minValue || ""}
                          onChange={(e) => handleNewRangeChange("minValue", e.target.value)}
                        />
                        <InputField
                          label="Max Value"
                          type="number"
                          value={newRangeEntry.maxValue || ""}
                          onChange={(e) => handleNewRangeChange("maxValue", e.target.value)}
                        />
                      </div>
                      <div className="flex flex-col sm:flex-row gap-3">
                        <button
                          onClick={handleAddOrUpdateRange}
                          disabled={!validateRangeEntry(newRangeEntry, standardRangeType)}
                          className="flex-1 flex items-center justify-center gap-2 px-5 py-2.5 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 font-medium"
                        >
                          <AddIcon className="w-5 h-5" />
                          {editingRangeIndex !== null ? "Update" : "Add"} Range
                        </button>
                        {editingRangeIndex !== null && (
                          <button
                            onClick={handleCancelEditRange}
                            className="px-5 py-2.5 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
                          >
                            Cancel
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </>
            )}

            {/* Submit */}
            <div className="flex flex-col sm:flex-row gap-4 pt-6 border-t border-blue-200">
              <button
                onClick={handleSubmit}
                className="flex-1 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-semibold shadow-sm"
              >
                Add Field
              </button>
              <button
                onClick={resetForm}
                className="flex-1 px-6 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-semibold"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AddField;

import { useState, useEffect } from "react";
import useStore from "./store";
import InputField from "../../components/html/InputField";
import SelectField from "../../components/html/SelectField";
import Icons from "../../components/icons"; // Import the icons

const PreviewForm = () => {
  const { schema, updateSection, deleteSection, updateField, deleteField, setPopup } = useStore();

  // Section editing states
  const [editingSection, setEditingSection] = useState(null);
  const [newSectionName, setNewSectionName] = useState("");

  // Field editing states
  const [editingField, setEditingField] = useState(null);
  const [fieldSection, setFieldSection] = useState("");
  const [fieldName, setFieldName] = useState("");
  const [fieldType, setFieldType] = useState("input");
  const [isRequired, setIsRequired] = useState(false);
  const [maxLength, setMaxLength] = useState("");
  const [options, setOptions] = useState([]);
  const [standardRangeType, setStandardRangeType] = useState("none");
  const [rangeData, setRangeData] = useState(null);
  const [unit, setUnit] = useState("");

  // FieldOptionsEditor states
  const [newOption, setNewOption] = useState("");
  const [editingOptionIndex, setEditingOptionIndex] = useState(null);
  const [editingOptionValue, setEditingOptionValue] = useState("");

  // StandardRangeEditor states
  const [newRangeEntry, setNewRangeEntry] = useState({});
  const [editingRangeIndex, setEditingRangeIndex] = useState(null);

  const needsOptions = ["select", "checkbox", "radio"].includes(fieldType);
  const needsMaxLength = ["input", "textarea"].includes(fieldType);
  const needsStandardRange = fieldType === "number" && standardRangeType !== "none";

  useEffect(() => {
    if (!["select", "checkbox", "radio"].includes(fieldType)) {
      setOptions([]);
      setNewOption("");
      setEditingOptionIndex(null);
      setEditingOptionValue("");
    }
    if (fieldType !== "number") {
      setUnit("");
      setStandardRangeType("none");
    }
  }, [fieldType]);

  useEffect(() => {
    if (standardRangeType === "simple" && (rangeData == null || !("min" in rangeData && "max" in rangeData))) {
      setRangeData({ min: "", max: "" });
    } else if (
      standardRangeType === "gender" &&
      (rangeData == null || !("male" in rangeData && "female" in rangeData))
    ) {
      setRangeData({ male: { min: "", max: "" }, female: { min: "", max: "" } });
    } else if (
      (standardRangeType === "age" || standardRangeType === "combined") &&
      (rangeData == null || !Array.isArray(rangeData))
    ) {
      setRangeData([]);
    } else if (standardRangeType === "none" && rangeData != null) {
      setRangeData(null);
    }
    setNewRangeEntry({});
    setEditingRangeIndex(null);
  }, [standardRangeType]);

  useEffect(() => {
    if (editingField && fieldSection) {
      const section = schema.sections.find((s) => s.name === fieldSection);
      if (!section || !section.fields.find((f) => f.name === editingField)) {
        resetFieldForm();
      }
    }
  }, [schema, editingField, fieldSection]);

  // FieldOptionsEditor handlers
  const handleAddOption = () => {
    if (newOption.trim()) {
      setOptions([...options, newOption.trim()]);
      setNewOption("");
    }
  };

  const handleRemoveOption = (index) => {
    setOptions(options.filter((_, i) => i !== index));
  };

  const handleStartEditOption = (index, value) => {
    setEditingOptionIndex(index);
    setEditingOptionValue(value);
  };

  const handleSaveEditOption = () => {
    if (editingOptionValue.trim()) {
      const updatedOptions = [...options];
      updatedOptions[editingOptionIndex] = editingOptionValue.trim();
      setOptions(updatedOptions);
      setEditingOptionIndex(null);
      setEditingOptionValue("");
    }
  };

  const handleCancelEditOption = () => {
    setEditingOptionIndex(null);
    setEditingOptionValue("");
  };

  // StandardRangeEditor handlers
  const handleSimpleOrGenderChange = (key, subKey, value) => {
    setRangeData((prev) => ({
      ...prev,
      [key]: subKey ? { ...prev[key], [subKey]: value } : value,
    }));
  };

  const handleNewRangeChange = (key, value) => {
    setNewRangeEntry((prev) => ({ ...prev, [key]: value }));
  };

  const validateRangeEntry = (entry, type) => {
    if (type === "age") {
      return entry.minAge && entry.minValue && entry.maxValue;
    } else if (type === "combined") {
      return entry.gender && entry.minAge && entry.minValue && entry.maxValue;
    }
    return false;
  };

  const handleAddOrUpdateRange = () => {
    if (validateRangeEntry(newRangeEntry, standardRangeType)) {
      const entry = { ...newRangeEntry };
      if (!entry.maxAge) entry.maxAge = 999;
      if (editingRangeIndex !== null) {
        const updated = [...rangeData];
        updated[editingRangeIndex] = entry;
        setRangeData(updated);
        setEditingRangeIndex(null);
        setPopup({ type: "success", message: "Range updated successfully" });
      } else {
        setRangeData((prev) => [...prev, entry]);
        setPopup({ type: "success", message: "Range added successfully" });
      }
      setNewRangeEntry({});
    } else {
      setPopup({ type: "error", message: "Please fill all required fields for the range" });
    }
  };

  const handleRemoveRange = (index) => {
    setRangeData((prev) => prev.filter((_, i) => i !== index));
  };

  const handleStartEditRange = (index) => {
    setEditingRangeIndex(index);
    setNewRangeEntry({ ...rangeData[index] });
  };

  const handleCancelEditRange = () => {
    setEditingRangeIndex(null);
    setNewRangeEntry({});
  };

  const startEditSection = (sectionName) => {
    setEditingSection(sectionName);
    setNewSectionName(sectionName);
  };

  const saveSection = () => {
    updateSection(editingSection, newSectionName);
    setEditingSection(null);
    setNewSectionName("");
  };

  const cancelEditSection = () => {
    setEditingSection(null);
    setNewSectionName("");
  };

  const startEditField = (sectionName, field) => {
    setFieldSection(sectionName);
    setEditingField(field.name);
    setFieldName(field.name);
    setFieldType(field.type);
    setIsRequired(field.required || false);
    setMaxLength(field.maxLength || "");
    setOptions(field.options || []);
    setUnit(field.unit || "");
    if (field.standardRange) {
      setStandardRangeType(field.standardRange.type);
      setRangeData(field.standardRange.data);
    } else {
      setStandardRangeType("none");
      setRangeData(null);
    }
    setNewOption("");
    setEditingOptionIndex(null);
    setEditingOptionValue("");
    setNewRangeEntry({});
    setEditingRangeIndex(null);
  };

  const handleUpdate = () => {
    if (!fieldName.trim()) {
      setPopup({ type: "error", message: "Field name is required" });
      return;
    }

    const allFields = schema.sections.flatMap((section) => section.fields || []);
    if (allFields.some((f) => f.name === fieldName && f.name !== editingField)) {
      setPopup({ type: "error", message: "Field name must be unique" });
      return;
    }

    if (needsOptions && options.length === 0) {
      setPopup({ type: "error", message: "At least one option is required for this field type" });
      return;
    }

    if (needsStandardRange) {
      if (standardRangeType === "simple") {
        if (!rangeData.min || !rangeData.max) {
          setPopup({ type: "error", message: "Min and max required for simple range" });
          return;
        }
      } else if (standardRangeType === "gender") {
        if (!rangeData.male.min || !rangeData.male.max || !rangeData.female.min || !rangeData.female.max) {
          setPopup({ type: "error", message: "Min and max required for both genders" });
          return;
        }
      } else if ((standardRangeType === "age" || standardRangeType === "combined") && rangeData.length === 0) {
        setPopup({ type: "error", message: "At least one range required" });
        return;
      }
    }

    const updatedField = {
      name: fieldName,
      type: fieldType,
      required: isRequired,
    };

    if (needsOptions) updatedField.options = options;
    if (needsMaxLength && maxLength) updatedField.maxLength = parseInt(maxLength, 10);
    if (needsStandardRange) {
      updatedField.standardRange = { type: standardRangeType, data: rangeData };
    }
    if (fieldType === "number" && unit.trim()) {
      updatedField.unit = unit.trim();
    }

    updateField(fieldSection, editingField, updatedField);
    resetFieldForm();
  };

  const resetFieldForm = () => {
    setEditingField(null);
    setFieldSection("");
    setFieldName("");
    setFieldType("input");
    setIsRequired(false);
    setMaxLength("");
    setOptions([]);
    setStandardRangeType("none");
    setRangeData(null);
    setUnit("");
    setNewOption("");
    setEditingOptionIndex(null);
    setEditingOptionValue("");
    setNewRangeEntry({});
    setEditingRangeIndex(null);
  };

  const handleCancelField = () => {
    resetFieldForm();
  };

  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-4 sm:p-5">
      <h3 className="text-lg font-semibold text-gray-800 mb-4">Form Preview</h3>
      {schema?.sections?.map((section) => (
        <div key={section.name} className="mb-6">
          <div className="flex flex-wrap items-center justify-between mb-2 gap-2">
            {editingSection === section.name ? (
              <div className="flex flex-wrap items-center gap-2">
                <InputField label="Title" value={newSectionName} onChange={(e) => setNewSectionName(e.target.value)} />
                <button
                  onClick={saveSection}
                  className="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 text-sm flex items-center gap-1"
                >
                  Save
                </button>
                <button
                  onClick={cancelEditSection}
                  className="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm flex items-center gap-1"
                >
                  Cancel
                </button>
              </div>
            ) : (
              <>
                <h4 className="text-md font-medium text-gray-800">{section.name}</h4>
                <div className="flex gap-2">
                  <button onClick={() => startEditSection(section.name)} className="btn-sm" title="Edit Section">
                    Edit
                  </button>
                  <button onClick={() => deleteSection(section.name)} className="delete-btn-sm" title="Delete Section">
                    Delete
                  </button>
                </div>
              </>
            )}
          </div>
          {section.fields.length === 0 ? (
            <p className="text-sm text-gray-600">No fields in this section</p>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full border-collapse min-w-[400px]">
                <thead>
                  <tr className="bg-gray-50">
                    <th className="p-2 text-left text-sm font-medium text-gray-700">Field Name</th>
                    <th className="p-2 text-left text-sm font-medium text-gray-700">Type</th>
                    <th className="p-2 text-left text-sm font-medium text-gray-700">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {section.fields.map((field) => (
                    <tr key={field.name} className="border-t border-gray-200">
                      <td className="p-2 text-sm text-gray-900">{field.name}</td>
                      <td className="p-2 text-sm text-gray-900">{field.type}</td>
                      <td className="p-2 flex gap-2">
                        <button
                          onClick={() => startEditField(section.name, field)}
                          className="btn-sm"
                          title="Edit Field"
                        >
                          Edit
                        </button>
                        <button
                          onClick={() => deleteField(section.name, field.name)}
                          className="delete-btn-sm"
                          title="Delete Field"
                        >
                          Delete
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      ))}

      {editingField && (
        <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <h4 className="text-md font-semibold mb-3 text-gray-800">Edit Field</h4>
          <div className="space-y-4">
            <InputField label="Field Name" value={fieldName} onChange={(e) => setFieldName(e.target.value)} />
            <SelectField
              label="Type"
              value={fieldType}
              onChange={(e) => setFieldType(e.target.value)}
              options={[
                { value: "input", label: "Text Input" },
                { value: "select", label: "Select Dropdown" },
                { value: "checkbox", label: "Checkbox Group" },
                { value: "radio", label: "Radio Group" },
                { value: "textarea", label: "Textarea" },
                { value: "number", label: "Number Input" },
              ]}
            />
            {needsMaxLength && (
              <InputField
                label="Max Length"
                type="number"
                value={maxLength}
                onChange={(e) => setMaxLength(e.target.value)}
              />
            )}
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={isRequired}
                onChange={(e) => setIsRequired(e.target.checked)}
                className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
              />
              <span className="text-sm text-gray-700">Mark as required</span>
            </label>
            {needsOptions && (
              <div className="space-y-3">
                <h5 className="text-sm font-medium text-gray-800">Options</h5>
                {options.length > 0 && (
                  <div className="space-y-2">
                    {options.map((opt, index) => (
                      <div key={index} className="flex flex-wrap items-center gap-2 bg-gray-50 p-2 rounded">
                        {editingOptionIndex === index ? (
                          <>
                            <input
                              type="text"
                              value={editingOptionValue}
                              onChange={(e) => setEditingOptionValue(e.target.value)}
                              className="flex-1 px-2 py-1 border border-gray-300 rounded text-sm"
                              autoFocus
                            />
                            <button
                              onClick={handleSaveEditOption}
                              className="text-xs text-green-600 hover:underline flex items-center gap-1"
                            >
                              <Icons.Edit className="w-3 h-3" />
                              Save
                            </button>
                            <button
                              onClick={handleCancelEditOption}
                              className="text-xs text-gray-600 hover:underline flex items-center gap-1"
                            >
                              <Icons.Close className="w-3 h-3" />
                              Cancel
                            </button>
                          </>
                        ) : (
                          <>
                            <span className="flex-1 text-sm text-gray-900">{opt}</span>
                            <button
                              onClick={() => handleStartEditOption(index, opt)}
                              className="text-xs text-blue-600 hover:underline flex items-center gap-1"
                            >
                              <Icons.Edit className="w-3 h-3" />
                              Edit
                            </button>
                            <button
                              onClick={() => handleRemoveOption(index)}
                              className="text-xs text-red-600 hover:underline flex items-center gap-1"
                            >
                              <Icons.Delete className="w-3 h-3" />
                              Remove
                            </button>
                          </>
                        )}
                      </div>
                    ))}
                  </div>
                )}
                <div className="flex flex-wrap items-end gap-2">
                  <InputField
                    label="New Option"
                    value={newOption}
                    onChange={(e) => setNewOption(e.target.value)}
                    className="flex-1"
                  />
                  <button
                    onClick={handleAddOption}
                    disabled={!newOption.trim()}
                    className="px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 text-sm flex items-center gap-1"
                  >
                    <Icons.Add className="w-4 h-4" />
                    Add
                  </button>
                </div>
              </div>
            )}
            {fieldType === "number" && (
              <>
                <InputField label="Unit (optional)" value={unit} onChange={(e) => setUnit(e.target.value)} />
                <div className="space-y-4">
                  <SelectField
                    label="Standard Range Type"
                    value={standardRangeType}
                    onChange={(e) => setStandardRangeType(e.target.value)}
                    options={[
                      { value: "none", label: "No Standard Range" },
                      { value: "simple", label: "Simple Range" },
                      { value: "age", label: "Age Based" },
                      { value: "gender", label: "Gender Based" },
                      { value: "combined", label: "Combined (Age and Gender)" },
                    ]}
                  />
                  {standardRangeType === "simple" && rangeData && (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      <InputField
                        label="Min Value"
                        type="number"
                        value={rangeData.min || ""}
                        onChange={(e) => handleSimpleOrGenderChange("min", null, e.target.value)}
                      />
                      <InputField
                        label="Max Value"
                        type="number"
                        value={rangeData.max || ""}
                        onChange={(e) => handleSimpleOrGenderChange("max", null, e.target.value)}
                      />
                    </div>
                  )}
                  {standardRangeType === "gender" && rangeData && (
                    <div className="space-y-4">
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <InputField
                          label="Male Min"
                          type="number"
                          value={rangeData.male?.min || ""}
                          onChange={(e) => handleSimpleOrGenderChange("male", "min", e.target.value)}
                        />
                        <InputField
                          label="Male Max"
                          type="number"
                          value={rangeData.male?.max || ""}
                          onChange={(e) => handleSimpleOrGenderChange("male", "max", e.target.value)}
                        />
                      </div>
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <InputField
                          label="Female Min"
                          type="number"
                          value={rangeData.female?.min || ""}
                          onChange={(e) => handleSimpleOrGenderChange("female", "min", e.target.value)}
                        />
                        <InputField
                          label="Female Max"
                          type="number"
                          value={rangeData.female?.max || ""}
                          onChange={(e) => handleSimpleOrGenderChange("female", "max", e.target.value)}
                        />
                      </div>
                    </div>
                  )}
                  {(standardRangeType === "age" || standardRangeType === "combined") && rangeData && (
                    <div className="space-y-3">
                      <h5 className="text-sm font-medium text-gray-800">Ranges</h5>
                      {rangeData.length > 0 && (
                        <div className="space-y-2">
                          {rangeData.map((range, index) => (
                            <div key={index} className="flex flex-wrap items-center gap-2 bg-gray-50 p-2 rounded">
                              <span className="flex-1 text-sm text-gray-900">
                                {standardRangeType === "combined"
                                  ? `${range.gender.charAt(0).toUpperCase() + range.gender.slice(1)} `
                                  : ""}
                                Age {range.minAge}-{range.maxAge === 999 ? "+" : range.maxAge}: {range.minValue}-
                                {range.maxValue}
                              </span>
                              <button
                                onClick={() => handleStartEditRange(index)}
                                className="text-xs text-blue-600 hover:underline flex items-center gap-1"
                              >
                                <Icons.Edit className="w-3 h-3" />
                                Edit
                              </button>
                              <button
                                onClick={() => handleRemoveRange(index)}
                                className="text-xs text-red-600 hover:underline flex items-center gap-1"
                              >
                                <Icons.Delete className="w-3 h-3" />
                                Remove
                              </button>
                            </div>
                          ))}
                        </div>
                      )}
                      <div className="space-y-2">
                        <div
                          className={`grid gap-2 grid-cols-1 sm:grid-cols-${
                            standardRangeType === "combined" ? "5" : "4"
                          }`}
                        >
                          {standardRangeType === "combined" && (
                            <SelectField
                              label="Gender"
                              value={newRangeEntry.gender || ""}
                              onChange={(e) => handleNewRangeChange("gender", e.target.value)}
                              options={[
                                { value: "male", label: "Male" },
                                { value: "female", label: "Female" },
                              ]}
                            />
                          )}
                          <InputField
                            label="Min Age"
                            type="number"
                            value={newRangeEntry.minAge || ""}
                            onChange={(e) => handleNewRangeChange("minAge", e.target.value)}
                          />
                          <InputField
                            label="Max Age"
                            type="number"
                            value={newRangeEntry.maxAge || ""}
                            onChange={(e) => handleNewRangeChange("maxAge", e.target.value)}
                          />
                          <InputField
                            label="Min Value"
                            type="number"
                            value={newRangeEntry.minValue || ""}
                            onChange={(e) => handleNewRangeChange("minValue", e.target.value)}
                          />
                          <InputField
                            label="Max Value"
                            type="number"
                            value={newRangeEntry.maxValue || ""}
                            onChange={(e) => handleNewRangeChange("maxValue", e.target.value)}
                          />
                        </div>
                      </div>
                      <div className="flex flex-wrap gap-2 mt-2">
                        <button
                          onClick={handleAddOrUpdateRange}
                          className="px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm flex items-center gap-1"
                          disabled={!validateRangeEntry(newRangeEntry, standardRangeType)}
                        >
                          {editingRangeIndex !== null ? (
                            <>
                              <Icons.Edit className="w-4 h-4" />
                              Update Range
                            </>
                          ) : (
                            <>
                              <Icons.Add className="w-4 h-4" />
                              Add Range
                            </>
                          )}
                        </button>
                        {editingRangeIndex !== null && (
                          <button
                            onClick={handleCancelEditRange}
                            className="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 text-sm flex items-center gap-1"
                          >
                            <Icons.Close className="w-4 h-4" />
                            Cancel
                          </button>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </>
            )}
            <div className="flex flex-wrap gap-3 mt-6">
              <button
                onClick={handleUpdate}
                className="flex-1 px-4 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm flex items-center justify-center gap-2"
              >
                <Icons.Edit className="w-4 h-4" />
                Update Field
              </button>
              <button
                onClick={handleCancelField}
                className="flex-1 px-4 py-2.5 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium text-sm flex items-center justify-center gap-2"
              >
                <Icons.Close className="w-4 h-4" />
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PreviewForm;

import { useState, useEffect } from "react";
import useStore from "./store";
import InputField from "../../components/html/InputField";
import SelectField from "../../components/html/SelectField";
import TextAreaField from "../../components/html/TextAreaField";

const FormRenderer = () => {
  const { schema } = useStore();

  const [gender, setGender] = useState("");
  const [age, setAge] = useState("");
  const [formData, setFormData] = useState({});
  const [statuses, setStatuses] = useState({});

  const hasMultipleSections = schema.sections?.length > 1;

  const computeStatus = (field, value, gender, age) => {
    if (field.type === "number" && field.standardRange) {
      const range = getApplicableRange(field.standardRange, gender, age);
      if (range) {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          if (numValue < range.min) return "below";
          else if (numValue > range.max) return "above";
          else return "within";
        }
      }
    }
    return "";
  };

  const updateAllStatuses = () => {
    const newStatuses = {};
    schema.sections.forEach((section) => {
      section.fields.forEach((field) => {
        const value = formData[field.name];
        if (value !== undefined) {
          newStatuses[field.name] = computeStatus(field, value, gender, age);
        }
      });
    });
    setStatuses(newStatuses);
  };

  useEffect(() => {
    updateAllStatuses();
  }, [age, gender]);

  const handleChange = (fieldName, value, isCheckbox = false) => {
    setFormData((prev) => {
      if (isCheckbox) {
        const currentValues = prev[fieldName] || [];
        const newValues = currentValues.includes(value)
          ? currentValues.filter((v) => v !== value)
          : [...currentValues, value];
        return { ...prev, [fieldName]: newValues };
      }
      return { ...prev, [fieldName]: value };
    });

    // Compute status for this field
    const field = findField(fieldName);
    if (field) {
      const newStatus = computeStatus(field, value, gender, age);
      setStatuses((prev) => ({ ...prev, [fieldName]: newStatus }));
    }
  };

  const findField = (name) => {
    for (let section of schema.sections || []) {
      for (let field of section.fields || []) {
        if (field.name === name) return field;
      }
    }
    return null;
  };

  const getApplicableRange = (sr, g, a) => {
    if (!g || !a) return null;
    const ageNum = parseFloat(a);
    if (isNaN(ageNum)) return null;
    const { type, data } = sr;

    let min,
      max,
      info = "";

    if (type === "simple") {
      min = parseFloat(data.min);
      max = parseFloat(data.max);
      info = "";
    } else if (type === "gender") {
      const gd = data[g.toLowerCase()];
      if (gd) {
        min = parseFloat(gd.min);
        max = parseFloat(gd.max);
        info = `for ${g.charAt(0).toUpperCase() + g.slice(1)}`;
      }
    } else if (type === "age") {
      for (let entry of data) {
        const minA = parseFloat(entry.minAge);
        const maxA = entry.maxAge !== 999 ? parseFloat(entry.maxAge) : Infinity;
        if (ageNum >= minA && ageNum <= maxA) {
          min = parseFloat(entry.minValue);
          max = parseFloat(entry.maxValue);
          const ageStr = `${entry.minAge}${entry.maxAge === 999 ? "+" : "-" + entry.maxAge}`;
          info = `for age ${ageStr}`;
          break;
        }
      }
    } else if (type === "combined") {
      for (let entry of data) {
        if (entry.gender.toLowerCase() === g.toLowerCase()) {
          const minA = parseFloat(entry.minAge);
          const maxA = entry.maxAge !== 999 ? parseFloat(entry.maxAge) : Infinity;
          if (ageNum >= minA && ageNum <= maxA) {
            min = parseFloat(entry.minValue);
            max = parseFloat(entry.maxValue);
            const ageStr = `${entry.minAge}${entry.maxAge === 999 ? "+" : "-" + entry.maxAge}`;
            info = `for ${entry.gender.charAt(0).toUpperCase() + entry.gender.slice(1)}, age ${ageStr}`;
            break;
          }
        }
      }
    }

    if (min !== undefined && max !== undefined) {
      return { min, max, info };
    }
    return null;
  };

  const renderField = (field) => {
    const { name, type, required, options = [], maxLength, unit = "", standardRange } = field;
    const value = formData[name] || (type === "checkbox" ? [] : "");
    const range = standardRange ? getApplicableRange(standardRange, gender, age) : null;
    const status = statuses[name] || "";
    const label = `${name}${unit ? ` (${unit})` : ""}${required ? " *" : ""}`;

    let inputElement;
    switch (type) {
      case "input":
        inputElement = (
          <InputField
            label={label}
            name={name}
            value={value}
            onChange={(e) => handleChange(name, e.target.value)}
            type="text"
            maxLength={maxLength}
            required={required}
          />
        );
        break;
      case "textarea":
        inputElement = (
          <TextAreaField
            label={label}
            name={name}
            value={value}
            onChange={(e) => handleChange(name, e.target.value)}
            maxLength={maxLength}
            required={required}
          />
        );
        break;
      case "select":
        inputElement = (
          <SelectField
            label={label}
            name={name}
            value={value}
            onChange={(e) => handleChange(name, e.target.value)}
            options={options.map((opt) => ({ value: opt, label: opt }))}
            placeholder="Select an option"
          />
        );
        break;
      case "radio":
        inputElement = (
          <div className="space-y-3">
            {options.map((opt) => (
              <label key={opt} className="flex items-center gap-3 cursor-pointer">
                <input
                  type="radio"
                  name={name}
                  value={opt}
                  checked={value === opt}
                  onChange={(e) => handleChange(name, e.target.value)}
                  required={required}
                  className="w-5 h-5 text-blue-600 focus:ring-blue-500 border-gray-200 rounded-full transition-all duration-200"
                />
                <span className="text-gray-700">{opt}</span>
              </label>
            ))}
          </div>
        );
        break;
      case "checkbox":
        inputElement = (
          <div className="space-y-3">
            {options.map((opt) => (
              <label key={opt} className="flex items-center gap-3 cursor-pointer">
                <input
                  type="checkbox"
                  value={opt}
                  checked={value.includes(opt)}
                  onChange={(e) => handleChange(name, opt, true)}
                  className="w-5 h-5 text-blue-600 focus:ring-blue-500 border-gray-200 rounded-md transition-all duration-200"
                />
                <span className="text-gray-700">{opt}</span>
              </label>
            ))}
          </div>
        );
        break;
      case "number":
        inputElement = (
          <InputField
            label={label}
            name={name}
            value={value}
            onChange={(e) => handleChange(name, e.target.value)}
            type="number"
            required={required}
          />
        );
        break;
      default:
        return null;
    }

    return (
      <div key={name} className="mb-6">
        {type === "radio" || type === "checkbox" ? (
          <label className="block mb-2 font-semibold text-gray-800">
            {name} {required ? <span className="text-red-500">*</span> : ""}
          </label>
        ) : null}
        {inputElement}
        {range && (
          <p className="mt-2 text-sm text-gray-500">
            Standard Range {range.info ? `${range.info} ` : ""}is {range.min} - {range.max} {unit}
          </p>
        )}
        {status && (
          <p className={`mt-2 text-sm font-medium ${status === "within" ? "text-green-600" : "text-red-600"}`}>
            Value is {status} the standard range.
          </p>
        )}
      </div>
    );
  };

  return (
    <div className="max-w-3xl mx-auto bg-white/30 backdrop-blur-lg p-8 rounded-2xl shadow-xl border border-white/20 my-8">
      <h2 className="text-2xl font-bold text-gray-900 mb-8">{schema.name || "Form Renderer"}</h2>
      <div className="mb-10">
        <h3 className="text-xl font-semibold text-gray-900 mb-6">Patient Details</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <SelectField
              label="Gender *"
              value={gender}
              onChange={(e) => setGender(e.target.value)}
              options={[
                { value: "male", label: "Male" },
                { value: "female", label: "Female" },
              ]}
              placeholder="Select Gender"
            />
          </div>
          <div>
            <InputField label="Age *" value={age} onChange={(e) => setAge(e.target.value)} type="number" />
          </div>
        </div>
      </div>
      {schema?.sections?.map((section) => (
        <div key={section.name} className="mb-10">
          {hasMultipleSections && (
            <h3 className="text-xl font-semibold text-gray-900 mb-6 border-b border-gray-200 pb-4">{section.name}</h3>
          )}
          {(section.fields || []).map((field) => renderField(field))}
        </div>
      ))}
    </div>
  );
};

export default FormRenderer;

import useStore from "./store";
import InputField from "../../components/html/InputField";

const Schema = () => {
  const { schema, setSchema } = useStore();
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      <h3 className="text-lg font-semibold text-gray-800 mb-4">Basic Information</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <InputField label="Schema Name" value={schema.name} onChange={(e) => setSchema("name", e.target.value)} />
        <InputField label="Test Name" value={schema.testName} onChange={(e) => setSchema("testName", e.target.value)} />
      </div>
    </div>
  );
};

export default Schema

import useStore from "./store";
const SchemaPreview = () => {
  const { schema } = useStore();

  const safeStringify = (obj) => {
    return JSON.stringify(
      obj,
      (key, value) => {
        if (typeof value === "function" || value instanceof HTMLElement) return undefined;
        return value;
      },
      2
    );
  };
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-2">
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-2 mb-4">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">Schema Preview</h3>
          <p className="text-sm text-gray-600">Live preview of schema data structure</p>
        </div>
        <div className="flex flex-wrap gap-2">
          <span className="px-3 py-1 rounded-full text-xs bg-gray-100 text-gray-700">
            {schema.sections?.length || 0} section(s)
          </span>
          <span
            className={`px-3 py-1 rounded-full text-xs ${
              schema.isActive ? "bg-green-100 text-green-700" : "bg-yellow-100 text-yellow-700"
            }`}
          >
            {schema.isActive ? "Active" : "Draft"}
          </span>
          <span
            className={`px-3 py-1 rounded-full text-xs ${
              schema.hasStaticStandardRange ? "bg-blue-100 text-blue-700" : "bg-gray-100 text-gray-700"
            }`}
          >
            {schema.hasStaticStandardRange ? "No Static Standard Range" : "No Range"}
          </span>
        </div>
      </div>

      <div className="bg-gray-50 rounded-lg border border-gray-200">
        <div className="p-2">
          <pre className="text-xs md:text-sm text-green-600 font-mono whitespace-pre-wrap break-words max-h-96 overflow-y-auto bg-gray-900  p-1 rounded border">
            {safeStringify(schema)}
          </pre>
        </div>
      </div>
    </div>
  );
};

export default SchemaPreview;

import { useState } from "react";
import useStore from "./store";
import InputField from "../../components/html/InputField";

const Section = () => {
  const [editingSectionName, setEditingSectionName] = useState(null);
  const [editingNewSectionName, setEditingNewSectionName] = useState("");
  const [showAddSectionInput, setShowAddSectionInput] = useState(false);

  const { schema, setSchema, addSection, updateSection, setPopup } = useStore();

  const startEditing = (section) => {
    setEditingSectionName(section.name);
    setEditingNewSectionName(section.name);
  };

  const saveEditing = () => {
    if (editingSectionName && editingNewSectionName.trim()) {
      updateSection(editingSectionName, editingNewSectionName);
      setEditingSectionName(null);
      setEditingNewSectionName("");
    }
  };

  const cancelEditing = () => {
    setEditingSectionName(null);
    setEditingNewSectionName("");
  };

  const handleAddSectionClick = () => {
    const success = addSection();
    if (success) {
      setShowAddSectionInput(false);
    } else {
      setShowAddSectionInput(true);
    }
  };

  const handleCancelAddSection = () => {
    setSchema("currentSectionName", "");
    setShowAddSectionInput(false);
  };

  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      <div className="flex items-center justify-between mb-4">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">Sections</h3>
          <p className="text-sm text-gray-600 mt-1">Organize test fields into sections</p>
        </div>
        {!showAddSectionInput && (
          <button
            onClick={() => setShowAddSectionInput(true)}
            className="px-5 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium text-sm"
          >
            Add Section
          </button>
        )}
      </div>

      {/* Add Section Input */}
      {showAddSectionInput && (
        <div className="mb-5 p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <InputField
            label="Section Title"
            value={schema.currentSectionName || ""}
            onChange={(e) => setSchema("currentSectionName", e.target.value)}
            autoFocus
          />
          <div className="flex gap-3 mt-4">
            <button
              onClick={handleAddSectionClick}
              disabled={!schema.currentSectionName?.trim()}
              className="flex-1 px-4 py-2.5 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors font-medium text-sm"
            >
              Add Section
            </button>
            <button
              onClick={handleCancelAddSection}
              className="flex-1 px-4 py-2.5 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors font-medium text-sm"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Existing Sections List */}
      {schema.sections?.length > 0 && (
        <div>
          <div className="flex justify-between items-center mb-3">
            <h4 className="text-sm font-medium text-gray-700">Existing Sections ({schema.sections.length})</h4>
            {schema.sections.length === 1 && <span className="text-xs text-gray-500">Default section is required</span>}
          </div>
          <div className="space-y-3">
            {schema.sections.map((section) => (
              <div key={section.name} className="bg-gray-50 rounded-lg p-4 border border-gray-200">
                {editingSectionName === section.name ? (
                  <div className="space-y-3">
                    <input
                      type="text"
                      value={editingNewSectionName}
                      onChange={(e) => setEditingNewSectionName(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                      placeholder="Section name"
                      autoFocus
                    />
                    <div className="flex gap-2">
                      <button
                        onClick={saveEditing}
                        className="flex-1 px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium"
                      >
                        Save
                      </button>
                      <button
                        onClick={cancelEditing}
                        className="flex-1 px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors text-sm font-medium"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-900 truncate">{section.name}</span>
                      {section.name === "Default" && (
                        <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded-full">Default</span>
                      )}
                    </div>
                    <div className="flex gap-2">
                      <button
                        onClick={() => startEditing(section)}
                        className="px-3 py-1.5 text-xs text-blue-600 bg-blue-50 hover:bg-blue-100 rounded transition-colors"
                      >
                        Edit
                      </button>
                      <button
                        onClick={() =>
                          setPopup({
                            type: "confirmation",
                            message: "All data will be lost. Are you sure?",
                            action: "deleteSection",
                            data: section.name,
                          })
                        }
                        className="px-3 py-1.5 text-xs text-red-600 bg-red-50 hover:bg-red-100 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled={schema.sections.length === 1}
                      >
                        Delete
                      </button>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default Section;

import { useEffect } from "react";
import SelectField from "../../components/html/SelectField";
import useStore from "./store";
const SelectTest = () => {
  const { loadTestList, testList, schema, setSchema } = useStore();

  useEffect(() => {
    loadTestList();
  }, []);

  const handleCategoryChange = (e) => {
    setSchema("categoryId", e.target.value);
    setSchema("testId", "");
  };

  const testsForSelectedCategory = schema.categoryId
    ? testList.find((cat) => cat._id === schema.categoryId)?.tests || []
    : [];

  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      <h3 className="text-lg font-semibold text-gray-800 mb-4">Test Selection</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <SelectField
          label="Test Category"
          value={schema.categoryId}
          onChange={handleCategoryChange}
          options={testList.map((category) => ({
            value: category._id,
            label: category.categoryName,
          }))}
          placeholder="Select a category"
        />
        <SelectField
          label="Specific Test"
          value={schema.testId}
          onChange={(e) => setSchema("testId", e.target.value)}
          options={testsForSelectedCategory.map((test) => ({
            value: test._id,
            label: `${test.name}${test.schemaId ? " (Attached)" : ""}`,
          }))}
          placeholder="Select a test"
          disabled={!schema.categoryId}
        />
      </div>
    </div>
  );
};

export default SelectTest;


import useStore from "./store";
import TextAreaField from "../../components/html/TextAreaField";
const StaticStandardRange = () => {
  const { schema, setSchema, confirmRemoveStaticStandardRange, clearStaticStandardRange } = useStore();

  const handleStandardRangeToggle = (value) => {
    if (!value && schema.staticStandardRange?.trim() !== "") {
      confirmRemoveStaticStandardRange();
    } else {
      setSchema("hasStaticStandardRange", value);
      if (!value) clearStaticStandardRange();
    }
  };
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      <div className="flex items-center justify-between mb-4">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">Static Standard Range</h3>
          <p className="text-sm text-gray-600 mt-1">Add static reference values for this test</p>
        </div>
        <label className="relative inline-flex items-center cursor-pointer">
          <input
            type="checkbox"
            checked={schema.hasStaticStandardRange}
            onChange={(e) => handleStandardRangeToggle(e.target.checked)}
            className="sr-only peer"
          />
          <div className="w-12 h-6 bg-gray-300 rounded-full peer peer-checked:bg-blue-600 after:content-[''] after:absolute after:top-0.5 after:left-0.5 after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-6"></div>
          <span className="ml-3 text-sm font-medium text-gray-700">
            {schema.hasStaticStandardRange ? "Enabled" : "Disabled"}
          </span>
        </label>
      </div>

      {schema.hasStaticStandardRange && (
        <div className="mt-4">
          <TextAreaField
            label="Reference Values"
            value={schema.staticStandardRange}
            onChange={(e) => setSchema("staticStandardRange", e.target.value)}
            rows={4}
          />
        </div>
      )}
    </div>
  );
};

export default StaticStandardRange;

import useStore from "./store";
const Status = () => {
  const { schema, setSchema } = useStore();
  const handleIsActiveChange = (e) => {
    setSchema("isActive", e.target.checked);
  };
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">Status</h3>
          <p className="text-sm text-gray-600 mt-1">
            {schema.isActive ? "Schema is active and can be used" : "Schema is in draft mode"}
          </p>
        </div>
        <label className="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" checked={schema.isActive} onChange={handleIsActiveChange} className="sr-only peer" />
          <div className="w-12 h-6 bg-gray-300 rounded-full peer peer-checked:bg-green-600 after:content-[''] after:absolute after:top-0.5 after:left-0.5 after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-6"></div>
          <span className="ml-3 text-sm font-medium text-gray-700">{schema.isActive ? "Active" : "Draft"}</span>
        </label>
      </div>
    </div>
  );
};

export default Status;


now your task is: while adding a new schema I dont need category ang more.... i only need to select the test only....
just modify the affected code only.